<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>OCR Tawkeel — Barcode + National ID (continuous)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js" defer></script>
  <style>
    :root { --muted:#666; --accent:#e33; --panel:#f7f7f7; }
    body{font-family:Arial,system-ui;direction:rtl;padding:12px;margin:0;color:#111}
    header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    h1{font-size:18px;margin:0}
    .viewer{position:relative;display:inline-block;margin-top:12px}
    video{border:2px solid #444;border-radius:8px;background:#000;display:block;max-width:90vw;height:auto}
    #roi-box{position:absolute;border:2px dashed var(--accent);box-sizing:border-box;pointer-events:none}
    #preview-canvas{position:absolute;pointer-events:none;image-rendering:pixelated;border-radius:4px;display:none;background:#fff}
    #controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
    #controls button{padding:8px 10px}
    .row{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
    pre{background:var(--panel);padding:8px;border-radius:6px;overflow:auto;max-height:220px;white-space:pre-wrap}
    #barcodeLabel{font-weight:bold;color:green;min-height:22px}
    #idLabel{font-weight:bold;color:#0a57a4;min-height:22px}
    #errorLine{color:#b00;font-weight:bold;min-height:18px}
    .small{font-size:13px;color:var(--muted)}
    footer{margin-top:14px;font-size:12px;color:var(--muted)}
    .hidden { display:none !important; }
    .settingsPanel { border:1px solid #eee;padding:10px;border-radius:6px; background: #fff; margin-bottom:10px; }
    .debugOnly { display:none; } /* elements shown only in Debug */
    @media (max-width:700px){video{width:360px;height:270px}}
  </style>
</head>
<body>
  <header>
    <h1>OCR Tawkeel</h1>
    <div>
      <button id="toggleDebugBtn" class="hidden">Debug</button>
    </div>
  </header>

  <main style="display:flex;gap:18px;flex-wrap:wrap;align-items:flex-start;justify-content:center">
    <section style="min-width:320px">
      <div class="viewer" id="viewerRoot">
        <video id="video" autoplay playsinline muted></video>
        <div id="roi-box" aria-hidden="true"></div>
        <canvas id="preview-canvas"></canvas>
      </div>

      <div id="controls" style="margin-top:10px">
        <!-- Debug-only action buttons -->
        <button id="togglePreview" class="debugOnly">عرض المعالجة</button>
        <button id="snapBtn" class="debugOnly">فتح Snap</button>
        <button id="runOnceBtn" class="debugOnly">جرب مرة واحدة الآن</button>

        <!-- زر إعادة التهيئة الكامل مسمى "جديد" -->
        <button id="resetAllBtn">جديد</button>

        <!-- copy log visible only in debug -->
        <button id="copyLogBtn" class="debugOnly hidden">نسخ سجل التشغيل</button>
      </div>

      <div class="row" style="margin-top:10px">
        <div><strong>رقم الباركود:</strong> <span id="barcodeLabel">Waiting...</span></div>
        <div><strong>رقم الهوية:</strong> <span id="idLabel">Waiting...</span></div>
        <div id="errorLine"></div>
      </div>

      <div style="margin-top:8px" class="small">ضع السطر/الهوية داخل الإطار الأحمر ثم اضغط "جديد" لإعادة التهيئة الكاملة أو فعّل Debug لرؤية أدوات المعالجة</div>

      <div style="margin-top:10px" id="roiControls" class="debugOnly hidden">
        <div class="row">
          <label>Center X%</label><input id="rX" type="range" min="0" max="100" value="50">
          <label>Center Y%</label><input id="rY" type="range" min="0" max="100" value="72">
        </div>
        <div class="row">
          <label>Width px</label><input id="rW" type="range" min="60" max="900" value="260">
          <label>Height px</label><input id="rH" type="range" min="12" max="400" value="60">
        </div>
      </div>
    </section>

    <aside style="min-width:420px;max-width:720px">
      <div id="settingsPanel" class="settingsPanel hidden debugOnly">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>خيارات المعالجة وTesseract (Debug only)</strong>
          <span class="small">Debug mode</span>
        </div>

        <div class="row" style="margin-top:8px">
          <label>PSM</label>
          <select id="psmSelect">
            <option value="7">7 - SINGLE_LINE</option>
            <option value="6">6 - SINGLE_BLOCK</option>
            <option value="3">3 - SINGLE_COLUMN</option>
            <option value="11">11 - Sparse text</option>
          </select>

          <label>Upscale</label>
          <select id="upscaleSelect">
            <option value="1">1x</option>
            <option value="1.5">1.5x</option>
            <option value="2" selected>2x</option>
            <option value="3">3x</option>
          </select>
        </div>

        <div class="row">
          <label>Threshold</label>
          <input id="threshRange" type="range" min="80" max="220" value="140"><span id="threshVal">140</span>
          <label>Sharpen</label>
          <input id="sharpenRange" type="range" min="0" max="3" step="0.5" value="1.0"><span id="sharpenVal">1.0</span>
        </div>

        <div class="row">
          <label>Median</label>
          <input id="medianRange" type="range" min="0" max="2" step="1" value="1"><span id="medianVal">1</span>
          <label>Force Invert</label><input id="forceInvert" type="checkbox">
        </div>

        <div style="margin-top:10px">
          <button id="clearLogBtn" style="font-size:12px">مسح السجل</button>
          <button id="flushLogsBtn" style="font-size:12px">عرض السجل</button>
        </div>
      </div>

      <div id="debugDiagnostics" class="hidden debugOnly">
        <div style="margin-top:10px;border:1px solid #eee;padding:10px;border-radius:6px">
          <div><strong>مخرجات تشخيصية (Debug)</strong></div>
          <div class="row" style="margin-top:8px">
            <div style="flex:1"><div><strong>Raw OCR</strong></div><pre id="raw">—</pre></div>
            <div style="flex:1"><div><strong>Words (text : confidence)</strong></div><pre id="words">—</pre></div>
          </div>
          <div style="margin-top:10px"><strong>سجل التشغيل</strong></div>
          <pre id="log">جاري التهيئة...</pre>
        </div>
      </div>

      <footer class="small" style="margin-top:8px">
        ملاحظة: الإعدادات والمخرجات التشخيصية مرئية فقط في وضع Debug. لتشغيل وضع Debug اضغط Ctrl+Shift+D أو افتح الصفحة مع ?debug=1
      </footer>
    </aside>
  </main>

  <canvas id="fullCanvas" style="display:none"></canvas>
  <canvas id="roiCanvas" style="display:none"></canvas>

<script>
/* ---------- تعاريف ---------- */
const BARCODE_REGEX = /ECP\d{8}EG/;
const ID_REGEX = new RegExp('^[23](0[0-9]|[0-9][0-9])(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])(01|02|03|04|05|06|11|12|13|14|15|16|17|18|19|21|22|23|24|25|26|27|28|29|31|32|33|34|35|88)[0-9]{5}$');

/* DOM */
const video = document.getElementById('video');
const viewerRoot = document.getElementById('viewerRoot');
const roiBox = document.getElementById('roi-box');
const previewCanvas = document.getElementById('preview-canvas');
const previewCtx = previewCanvas.getContext('2d');
const fullCanvas = document.getElementById('fullCanvas');
const fullCtx = fullCanvas.getContext('2d', { willReadFrequently: true });
const roiCanvas = document.getElementById('roiCanvas');
const roiCtx = roiCanvas.getContext('2d', { willReadFrequently: true });

const barcodeLabel = document.getElementById('barcodeLabel');
const idLabel = document.getElementById('idLabel');
const rawEl = document.getElementById('raw');
const wordsEl = document.getElementById('words');
const logEl = document.getElementById('log');
const errorLine = document.getElementById('errorLine');

const togglePreview = document.getElementById('togglePreview');
const snapBtn = document.getElementById('snapBtn');
const runOnceBtn = document.getElementById('runOnceBtn');
const resetAllBtn = document.getElementById('resetAllBtn');
const copyLogBtn = document.getElementById('copyLogBtn');
const clearLogBtn = document.getElementById('clearLogBtn');
const toggleDebugBtn = document.getElementById('toggleDebugBtn');
const flushLogsBtn = document.getElementById('flushLogsBtn');

const psmSelect = document.getElementById('psmSelect');
const upscaleSelect = document.getElementById('upscaleSelect');
const threshRange = document.getElementById('threshRange');
const threshVal = document.getElementById('threshVal');
const sharpenRange = document.getElementById('sharpenRange');
const sharpenVal = document.getElementById('sharpenVal');
const medianRange = document.getElementById('medianRange');
const medianVal = document.getElementById('medianVal');
const forceInvert = document.getElementById('forceInvert');

const rX = document.getElementById('rX'), rY = document.getElementById('rY'), rW = document.getElementById('rW'), rH = document.getElementById('rH');
const settingsPanel = document.getElementById('settingsPanel');
const roiControls = document.getElementById('roiControls');
const debugDiagnostics = document.getElementById('debugDiagnostics');

/* ---------- حالات وعدادات الاستقرار ---------- */
let ROI = { cxPerc:50, cyPerc:72, wPx:260, hPx:60 };
let showPreview = false, workerReady = false, videoReady = false;
let worker = null;
let scanning = true;

let lastAttempt = 0;
const minInterval = 400;
const requiredStable = 2;

let foundBarcode = null;
let foundID = null;

let lastBarcodeCandidate = null;
let stableBarcodeCount = 0;
let lastIDCandidate = null;
let stableIDCount = 0;

const MAX_ATTEMPTS = 2000;
let attemptsCount = 0;

/* Debug flag sources */
const urlParams = new URLSearchParams(location.search);
const DEBUG_QP = urlParams.get('debug') === '1';
const DEBUG_LS = localStorage.getItem('ocr_debug') === '1';
let DEBUG = Boolean(DEBUG_QP || DEBUG_LS);

/* apply debug UI */
function setDebugUIVisible(on){
  const els = document.querySelectorAll('.debugOnly');
  els.forEach(e => { e.style.display = on ? '' : 'none'; });
  if (on) {
    settingsPanel.classList.remove('hidden');
    debugDiagnostics.classList.remove('hidden');
    copyLogBtn.classList.remove('hidden');
  } else {
    settingsPanel.classList.add('hidden');
    debugDiagnostics.classList.add('hidden');
    copyLogBtn.classList.add('hidden');
  }
}
setDebugUIVisible(DEBUG);

/* logging buffer */
const LOG_BUFFER = [];
function appendLog(line){
  const t = new Date().toLocaleTimeString();
  const entry = `[${t}] ${line}`;
  LOG_BUFFER.unshift(entry);
  if (LOG_BUFFER.length > 1000) LOG_BUFFER.pop();
  if (DEBUG && logEl) logEl.textContent = LOG_BUFFER.join('\n');
  if (/error/i.test(line)) console.error(entry);
}
function setError(msg){ errorLine.textContent = msg || ''; appendLog('ERROR: ' + (msg||'')); }

/* ensure ROI border red (CSS var --accent already red) */
(function applyROIColor(){ roiBox.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#e33'; })();

/* ---------- كاميرا ---------- */
async function startCamera(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width:{ ideal:1280 }, height:{ ideal:720 } } });
    video.srcObject = stream;
    appendLog('Camera stream started');
  } catch (e) {
    appendLog('Camera error: ' + (e && e.message ? e.message : e));
    setError('خطأ بالكاميرا: ' + (e && e.message ? e.message : e));
  }
}

/* ---------- تحميل Tesseract وتهيئة العامل ---------- */
async function loadTesseractIfNeeded(){
  if (window.Tesseract) return window.Tesseract;
  appendLog('Lazy-loading Tesseract.js');
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js';
    s.crossOrigin = 'anonymous';
    s.onload = () => { appendLog('Tesseract script loaded'); resolve(window.Tesseract); };
    s.onerror = (e) => { appendLog('Failed to load Tesseract script'); reject(e); };
    document.head.appendChild(s);
  });
}

async function initWorker(){
  appendLog('Initializing Tesseract worker (compat mode)...');
  try {
    await loadTesseractIfNeeded();
  } catch(e){
    appendLog('Failed loading tesseract: ' + e);
    setError('فشل تحميل مكتبة Tesseract');
    return;
  }
  try {
    if (typeof Tesseract !== 'undefined' && typeof Tesseract.createWorker === 'function') {
      const createWorkerFn = Tesseract.createWorker;
      appendLog('Using Tesseract.createWorker');
      worker = createWorkerFn({ logger: m => appendLog('Tesseract: ' + (m.status || '') + ' ' + (m.progress ? (m.progress*100).toFixed(1)+'%' : '')) });
      if (!worker || typeof worker.load !== 'function') throw new Error('Worker does not expose load()');
      await worker.load(); appendLog('worker.load OK');
      await worker.loadLanguage('eng'); appendLog('language loaded: eng');
      await worker.initialize('eng'); appendLog('worker initialized');
      if (typeof worker.setParameters === 'function') {
        try { await worker.setParameters({ tessedit_char_whitelist: 'ECP0123456789EG0123456789' }); } catch(e){ appendLog('initial setParameters failed: ' + e); }
      }
      workerReady = true; appendLog('Worker ready (createWorker)');
      if (videoReady) startLoop();
      return;
    }

    if (typeof Tesseract !== 'undefined' && typeof Tesseract.recognize === 'function') {
      appendLog('Fallback: using Tesseract.recognize');
      worker = {
        recognize: async (blob, opts={}) => {
          if (!blob) throw new Error('recognize: blob null');
          const tmpUrl = URL.createObjectURL(blob);
          try { const res = await Tesseract.recognize(tmpUrl, 'eng', opts); return res; } finally { URL.revokeObjectURL(tmpUrl); }
        },
        setParameters: async () => {},
        terminate: async () => {}
      };
      workerReady = true; appendLog('Worker ready (fallback recognize)');
      if (videoReady) startLoop();
      return;
    }

    appendLog('No suitable Tesseract interface found');
    setError('لم يتم تحميل واجهة Tesseract المناسبة. استخدم CDN متوافق.');
  } catch(err){
    appendLog('initWorker error: ' + (err && err.message ? err.message : err));
    setError('خطأ بتهيئة العامل: ' + (err && err.message ? err.message : err));
    worker = null;
  }
}

/* ---------- معالجة الصورة: وظائف مساعدة ---------- */
function grayscaleContrast(data, contrastFactor){
  const intercept = 128 * (1 - contrastFactor);
  for (let i=0;i<data.length;i+=4){
    const g = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
    let v = g * contrastFactor + intercept;
    data[i]=data[i+1]=data[i+2]=v;
  }
}
function sharpen(data,w,h,amount){ if (!amount||amount<=0) return; const copy=new Uint8ClampedArray(data); for (let y=1;y<h-1;y++){ for (let x=1;x<w-1;x++){ const idx=(y*w+x)*4; const center=copy[idx]; const up=copy[((y-1)*w+x)*4]; const down=copy[((y+1)*w+x)*4]; const left=copy[(y*w+(x-1))*4]; const right=copy[(y*w+(x+1))*4]; let v=(1+amount*4)*center - amount*(up+down+left+right); v=Math.max(0,Math.min(255,v)); data[idx]=data[idx+1]=data[idx+2]=v; } } }
function medianBlur(data,w,h,passes){ if (!passes||passes<=0) return; for (let p=0;p<passes;p++){ const copy=new Uint8ClampedArray(data); for (let y=1;y<h-1;y++){ for (let x=1;x<w-1;x++){ const vals=[]; for (let yy=-1;yy<=1;yy++){ for (let xx=-1;xx<=1;xx++){ const id=((y+yy)*w + (x+xx))*4; vals.push(copy[id]); } } vals.sort((a,b)=>a-b); const med=vals[4]; const idc=(y*w + x)*4; data[idc]=data[idc+1]=data[idc+2]=med; } } } }
function thresholdBinary(data,t){ let whiteCount=0; for (let i=0;i<data.length;i+=4){ const v = data[i] > t ? 255:0; data[i]=data[i+1]=data[i+2]=v; if (v===255) whiteCount++; } return whiteCount; }
function invertColors(data){ for (let i=0;i<data.length;i+=4){ const v = 255 - data[i]; data[i]=data[i+1]=data[i+2]=v; }}

/* ---------- ROI ---------- */
function positionROI(){
  const vRect = video.getBoundingClientRect();
  const rootRect = viewerRoot.getBoundingClientRect();
  const boxW = ROI.wPx, boxH = ROI.hPx;
  const leftInViewer = Math.round((vRect.width * ROI.cxPerc/100) - boxW/2);
  const topInViewer = Math.round((vRect.height * ROI.cyPerc/100) - boxH/2);
  roiBox.style.width = boxW + 'px';
  roiBox.style.height = boxH + 'px';
  roiBox.style.left = (leftInViewer + (vRect.left - rootRect.left)) + 'px';
  roiBox.style.top = (topInViewer + (vRect.top - rootRect.top)) + 'px';
  previewCanvas.style.left = roiBox.style.left;
  previewCanvas.style.top = roiBox.style.top;
  previewCanvas.style.width = boxW + 'px';
  previewCanvas.style.height = boxH + 'px';
  previewCanvas.width = boxW;
  previewCanvas.height = boxH;
}
function computeROIforCapture(){
  const vRect = video.getBoundingClientRect();
  const vw = vRect.width, vh = vRect.height;
  const boxW = ROI.wPx, boxH = ROI.hPx;
  const leftInViewer = (vw * ROI.cxPerc/100) - boxW/2;
  const topInViewer = (vh * ROI.cyPerc/100) - boxH/2;
  const scaleX = fullCanvas.width / vw;
  const scaleY = fullCanvas.height / vh;
  const sx = Math.round(leftInViewer * scaleX);
  const sy = Math.round(topInViewer * scaleY);
  const sw = Math.round(boxW * scaleX);
  const sh = Math.round(boxH * scaleY);
  return { sx, sy, sw, sh, dstW: previewCanvas.width, dstH: previewCanvas.height };
}

/* ---------- تحضير Blob للـ OCR ---------- */
async function prepareROIBlob(){
  try { fullCtx.drawImage(video,0,0,fullCanvas.width,fullCanvas.height); } catch(e){ appendLog('drawImage error: ' + e); setError('خطأ رسم الفريم'); return null; }
  const { sx, sy, sw, sh, dstW, dstH } = computeROIforCapture();
  if (sw <= 0 || sh <= 0){ appendLog('ROI خارج الفيديو'); setError('ROI خارج إطار الفيديو'); return null; }
  const factor = Number(upscaleSelect.value) || 2;
  const targetW = Math.max(120, Math.round(dstW * factor));
  const targetH = Math.max(24, Math.round(dstH * factor));
  roiCanvas.width = targetW; roiCanvas.height = targetH; roiCtx.clearRect(0,0,targetW,targetH);
  const safeSx = Math.max(0, Math.min(fullCanvas.width-1, sx));
  const safeSy = Math.max(0, Math.min(fullCanvas.height-1, sy));
  const safeSw = Math.max(1, Math.min(fullCanvas.width - safeSx, sw));
  const safeSh = Math.max(1, Math.min(fullCanvas.height - safeSy, sh));
  roiCtx.drawImage(fullCanvas, safeSx, safeSy, safeSw, safeSh, 0, 0, targetW, targetH);
  let img; try { img = roiCtx.getImageData(0,0,targetW,targetH); } catch(e){ appendLog('getImageData failed: ' + e); setError('getImageData failed'); return null; }
  const data = img.data;
  const contrastFactor = 1.6; grayscaleContrast(data, contrastFactor);
  const sharpenAmount = Number(sharpenRange.value) || 0; if (sharpenAmount>0) sharpen(data,targetW,targetH,sharpenAmount);
  const medianPasses = Number(medianRange.value) || 0; if (medianPasses>0) medianBlur(data,targetW,targetH,medianPasses);
  const thresh = Number(threshRange.value) || 140; const whiteCount = thresholdBinary(data,thresh);
  const whiteRatio = whiteCount / (data.length/4);
  const force = forceInvert.checked;
  if (force){ invertColors(data); appendLog('Force invert applied'); }
  else { if (whiteRatio < 0.5){ invertColors(data); appendLog('Auto invert applied (whiteRatio=' + whiteRatio.toFixed(2) + ')'); } else appendLog('No invert (whiteRatio=' + whiteRatio.toFixed(2) + ')'); }
  roiCtx.putImageData(img,0,0);
  if (showPreview){ try{ previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height); previewCtx.drawImage(roiCanvas,0,0,previewCanvas.width,previewCanvas.height); } catch(e){ appendLog('preview draw error: ' + e); } previewCanvas.style.display='block'; }
  return new Promise(resolve => { roiCanvas.toBlob(b => { if (!b){ appendLog('toBlob null'); resolve(null); } else if (b.size < 150){ appendLog('blob too small: ' + b.size); resolve(null); } else resolve(b); }, 'image/png'); });
}

/* ---------- recognize safety ---------- */
async function attemptRecognizeWithBlob(blob, opts){
  try {
    const res = await worker.recognize(blob, opts && opts.lang ? opts.lang : 'eng', opts && opts.options ? opts.options : {});
    return res;
  } catch (e){
    const msg = (e && e.message) ? e.message.toLowerCase() : '';
    if (msg.includes('endwith') || msg.includes('endswith') || msg.includes('is not a function') || msg.includes('undefined')){
      appendLog('Direct blob recognize failed: ' + (e && e.message ? e.message : e));
      return null;
    }
    throw e;
  }
}
async function safeRecognize(blob, opts){
  if (!blob) throw new Error('safeRecognize: blob null');
  if (!worker) throw new Error('safeRecognize: worker null');
  if (typeof worker.recognize !== 'function') throw new Error('safeRecognize: worker.recognize missing');
  const tryDirect = await attemptRecognizeWithBlob(blob, opts).catch(e => { appendLog('attemptRecognizeWithBlob threw: ' + e); return null; });
  if (tryDirect) return tryDirect;
  const url = URL.createObjectURL(blob);
  try { const res = await worker.recognize(url, opts && opts.lang ? opts.lang : 'eng', opts && opts.options ? opts.options : {}); return res; } finally { URL.revokeObjectURL(url); }
}

/* ---------- استخراج ---------- */
function extractBarcodeAndID(text){
  const cleaned = (text || '').replace(/\s+/g, '');
  const barcodeMatch = cleaned.match(BARCODE_REGEX);
  let idMatch = null;
  const digitSeqs = (cleaned.match(/\d{10,14}/g) || []);
  for (const seq of digitSeqs){
    if (ID_REGEX.test(seq)){
      idMatch = seq;
      break;
    }
  }
  if (!idMatch && ID_REGEX.test(cleaned)) idMatch = cleaned.match(ID_REGEX)[0];
  return { barcode: barcodeMatch ? barcodeMatch[0] : null, id: idMatch };
}

/* ---------- doOCROnce ---------- */
async function doOCROnce(){
  setError('');
  if (DEBUG) { rawEl.textContent = '—'; wordsEl.textContent = '—'; }
  if (!workerReady){ setError('عامل Tesseract غير جاهز'); appendLog('Worker not ready'); return null; }
  if (!videoReady){ setError('الكاميرا غير جاهزة'); appendLog('Video not ready'); return null; }
  const blob = await prepareROIBlob();
  if (!blob){ setError('الصورة المعالجة فارغة أو صغيرة — عدّل ROI/الإضاءة/الإعدادات'); return null; }
  const psm = Number(psmSelect.value) || 7;
  try {
    if (typeof worker.setParameters === 'function') {
      try { await worker.setParameters({ tessedit_char_whitelist: 'ECP0123456789EG0123456789', tessedit_pageseg_mode: psm }); } catch(e){ appendLog('setParameters failed: ' + e); }
    }
  } catch(e){ appendLog('setParameters outer error: ' + e); }
  appendLog('بدء recognize (PSM=' + psm + ') ...');
  try {
    const res = await safeRecognize(blob, { lang: 'eng' });
    if (!res || !res.data){ appendLog('recognize returned no data'); setError('recognize returned no data'); return null; }
    if (DEBUG) rawEl.textContent = res.data.text || '';
    if (DEBUG) {
      if (res.data.words && res.data.words.length) wordsEl.textContent = res.data.words.map(w => `${w.text} : ${Math.round(w.confidence)}`).join('\n');
      else wordsEl.textContent = '—';
    }
    appendLog('recognize OK, text length: ' + (res.data.text ? res.data.text.length : 0));
    const { barcode, id } = extractBarcodeAndID(res.data.text || '');
    if (barcode) appendLog('Barcode candidate from OCR: ' + barcode);
    if (id) appendLog('ID candidate from OCR: ' + id);
    return { barcode, id };
  } catch (e){ appendLog('recognize error: ' + (e && e.message ? e.message : e)); setError('خطأ أثناء التعرف: ' + (e && e.message ? e.message : e)); return null; }
}

/* ---------- حلقة المسح ---------- */
async function startLoop(){
  if (!workerReady || !videoReady){ appendLog('لا يمكن بدء اللوب - عامل أو فيديو غير جاهزين'); return; }
  scanning = true;
  barcodeLabel.textContent = foundBarcode || 'Waiting...';
  idLabel.textContent = foundID || 'Waiting...';
  setError('');
  attemptsCount = 0;

  while (scanning){
    const now = Date.now();
    if (now - lastAttempt < minInterval){ await new Promise(r=>setTimeout(r, minInterval)); continue; }
    lastAttempt = now;
    attemptsCount++;

    try {
      const res = await doOCROnce();
      if (!res){
        stableBarcodeCount = 0;
        stableIDCount = 0;
      } else {
        if (res.barcode){
          if (res.barcode === lastBarcodeCandidate) stableBarcodeCount++; else { lastBarcodeCandidate = res.barcode; stableBarcodeCount = 1; }
          appendLog('Barcode candidate: ' + res.barcode + ' (stable=' + stableBarcodeCount + ')');
          if (stableBarcodeCount >= requiredStable && !foundBarcode){
            foundBarcode = lastBarcodeCandidate;
            barcodeLabel.textContent = foundBarcode;
            appendLog('Barcode confirmed: ' + foundBarcode);
          }
        } else {
          lastBarcodeCandidate = null;
          stableBarcodeCount = 0;
        }

        if (res.id){
          if (res.id === lastIDCandidate) stableIDCount++; else { lastIDCandidate = res.id; stableIDCount = 1; }
          appendLog('ID candidate: ' + res.id + ' (stable=' + stableIDCount + ')');
          if (stableIDCount >= requiredStable && !foundID){
            foundID = lastIDCandidate;
            idLabel.textContent = foundID;
            appendLog('ID confirmed: ' + foundID);
          }
        } else {
          lastIDCandidate = null;
          stableIDCount = 0;
        }
      }

      if (foundBarcode && foundID){
        appendLog('Both barcode and ID confirmed. Stopping automatic loop.');
        scanning = false;
        break;
      }

      if (attemptsCount >= MAX_ATTEMPTS){
        appendLog('Reached max attempts (' + MAX_ATTEMPTS + '). Stopping.');
        scanning = false;
        break;
      }

    } catch(e){
      appendLog('Loop error: ' + e);
      await new Promise(r=>setTimeout(r,500));
    }
    await new Promise(r=>setTimeout(r,200));
  }
}

/* ---------- زر "جديد" : إعادة التهيئة الكامل ---------- */
resetAllBtn.addEventListener('click', ()=> {
  appendLog('Full reset requested via "جديد". Clearing all state to defaults.');
  // إيقاف الحلقة الحالية
  scanning = false;
  // مسح القيم المؤكدة والمرشحين والعدادات
  foundBarcode = null; foundID = null;
  lastBarcodeCandidate = null; stableBarcodeCount = 0;
  lastIDCandidate = null; stableIDCount = 0;
  attemptsCount = 0;
  // إعادة عرض واجهة افتراضية
  barcodeLabel.textContent = 'Waiting...';
  idLabel.textContent = 'Waiting...';
  setError('');
  // إعادة تهيئة ROI إلى الافتراضيات (اختياري، نعيدها هنا)
  ROI = { cxPerc:50, cyPerc:72, wPx:260, hPx:60 };
  positionROI();
  // أعد تشغيل الحلقة بعد قصيدة قصيرة لتفادي سباق حالة
  setTimeout(()=>{ scanning = true; if (workerReady && videoReady) startLoop(); }, 150);
});

/* ---------- أزرار Debug الأخرى ---------- */
togglePreview.addEventListener('click', ()=>{ showPreview = !showPreview; previewCanvas.style.display = showPreview ? 'block' : 'none'; togglePreview.textContent = showPreview ? 'اخفاء المعالجة' : 'عرض المعالجة'; positionROI(); });
snapBtn.addEventListener('click', async ()=>{ const b = await prepareROIBlob(); if (!b){ alert('الصورة فارغة أو صغيرة. عدّل ROI/الإضاءة'); return; } window.open(URL.createObjectURL(b), '_blank'); });
runOnceBtn.addEventListener('click', async ()=>{ await doOCROnce(); });

/* copy log */
copyLogBtn.addEventListener('click', async () => {
  try {
    const text = LOG_BUFFER.join('\n') || '';
    if (!text) { appendLog('لا يوجد شيء لنسخه من السجل'); return; }
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      appendLog('تم نسخ سجل التشغيل إلى الحافظة');
      copyLogBtn.textContent = 'تم النسخ'; setTimeout(()=>copyLogBtn.textContent='نسخ سجل التشغيل',1500);
      return;
    }
    const ta = document.createElement('textarea'); ta.value = text; ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta); ta.select();
    const ok = document.execCommand('copy'); document.body.removeChild(ta);
    if (ok) { appendLog('تم نسخ سجل التشغيل (fallback)'); copyLogBtn.textContent='تم النسخ'; setTimeout(()=>copyLogBtn.textContent='نسخ سجل التشغيل',1500); }
    else { appendLog('فشل النسخ'); setError('فشل النسخ — انسخ يدوياً'); }
  } catch(err){ appendLog('خطأ أثناء النسخ: ' + (err && err.message ? err.message : err)); setError('خطأ أثناء النسخ'); }
});

clearLogBtn && clearLogBtn.addEventListener('click', ()=>{ LOG_BUFFER.length = 0; if (DEBUG && logEl) logEl.textContent=''; appendLog('log cleared'); });
flushLogsBtn && flushLogsBtn.addEventListener('click', ()=>{ if (logEl) logEl.textContent = LOG_BUFFER.join('\n'); });

psmSelect.addEventListener('change', ()=> appendLog('PSM changed to ' + psmSelect.value));
upscaleSelect.addEventListener('change', ()=> appendLog('Upscale set to ' + upscaleSelect.value));
threshRange.addEventListener('input', ()=> { threshVal.textContent = threshRange.value; appendLog('Threshold=' + threshRange.value); });
sharpenRange.addEventListener('input', ()=> { sharpenVal.textContent = sharpenRange.value; });
medianRange.addEventListener('input', ()=> { medianVal.textContent = medianRange.value; });

[rX,rY,rW,rH].forEach(el => el && el.addEventListener('input', ()=>{ ROI.cxPerc = Number(rX.value); ROI.cyPerc = Number(rY.value); ROI.wPx = Number(rW.value); ROI.hPx = Number(rH.value); positionROI(); }));

/* Ctrl+Shift+D toggles debug */
window.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'd') {
    DEBUG = !DEBUG;
    if (DEBUG) localStorage.setItem('ocr_debug','1'); else localStorage.removeItem('ocr_debug');
    setDebugUIVisible(DEBUG);
    appendLog('Debug toggled via shortcut: ' + (DEBUG ? 'on' : 'off'));
  }
});

/* optional debug button */
toggleDebugBtn.addEventListener('click', ()=> {
  DEBUG = !DEBUG;
  if (DEBUG) localStorage.setItem('ocr_debug','1'); else localStorage.removeItem('ocr_debug');
  setDebugUIVisible(DEBUG);
  appendLog('Debug toggled via button: ' + (DEBUG ? 'on' : 'off'));
});

/* video metadata & start */
video.addEventListener('loadedmetadata', ()=> {
  fullCanvas.width = video.videoWidth || 1280;
  fullCanvas.height = video.videoHeight || 720;
  const maxW = Math.min(980, window.innerWidth - 40);
  video.style.width = maxW + 'px';
  video.style.height = (maxW * (fullCanvas.height / fullCanvas.width)) + 'px';
  rX && (rX.value = ROI.cxPerc);
  rY && (rY.value = ROI.cyPerc);
  rW && (rW.value = ROI.wPx);
  rH && (rH.value = ROI.hPx);
  positionROI();
  videoReady = true;
  appendLog('Video ready (metadata)');
  if (!workerReady) initWorker();
  if (workerReady) startLoop();
});

/* init */
startCamera();
appendLog('Page loaded; debug=' + (DEBUG ? 'on' : 'off'));
if (DEBUG) setDebugUIVisible(true);
if (!workerReady) initWorker();

/* cleanup */
window.addEventListener('beforeunload', async () => {
  try { if (worker && typeof worker.terminate === 'function') await worker.terminate(); } catch(e){}
});
</script>
</body>
</html>
