<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>OCR Tawkeel - Fixed</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: Arial, sans-serif; text-align:center; padding:12px; }
    .viewer { position:relative; display:inline-block; }
    video { border:2px solid #444; border-radius:8px; background:#000; width:640px; height:480px; object-fit:cover; }
    #roi-box { position:absolute; width:250px; height:60px; border:2px dashed red; left:50%; transform:translateX(-50%); top:320px; box-sizing:border-box; pointer-events:none; }
    /* preview canvas Ø³ÙŠØ¬Ù„Ø³ ØªÙ…Ø§Ù…Ø§Ù‹ Ø¯Ø§Ø®Ù„ Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù€ ROI */
    #preview-overlay { position:absolute; left:50%; transform:translateX(-50%); top:320px; width:250px; height:60px; pointer-events:none; display:none; image-rendering:pixelated; }
    #controls { margin-top:12px; }
    #result { font-weight:bold; color:green; min-height:26px; margin-top:10px; }
    button { padding:8px 12px; margin:0 6px; }
    @media (max-width:700px) {
      video { width:360px; height:270px; }
      #roi-box, #preview-overlay { width:200px; height:48px; top:200px; }
    }
  </style>
</head>
<body>
  <h3>OCR Tawkeel â€” Fixed Reliable Version</h3>

  <div class="viewer" id="viewer">
    <video id="video" autoplay playsinline></video>
    <div id="roi-box" aria-hidden="true"></div>
    <canvas id="preview-overlay"></canvas>
  </div>

  <div id="controls">
    <button id="togglePreview">Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©</button>
    <button id="restartBtn">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©</button>
  </div>

  <div id="result">Waiting...</div>

  <!-- Ø®Ù„ÙÙŠØ© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ù…Ø®ÙÙŠØ©) -->
  <canvas id="fullCanvas" width="640" height="480" style="display:none"></canvas>
  <canvas id="roiCanvas" width="360" height="80" style="display:none"></canvas>

<script>
  // Ø«Ø¨Ù‘Øª Ø§Ù„Ø±ÙŠØ¬ÙŠÙƒØ³ ÙƒÙ…Ø§ Ø·Ù„Ø¨Øª
  const TARGET_REGEX = /ECP\d{8}EG/;

  const video = document.getElementById('video');
  const preview = document.getElementById('preview-overlay');
  const previewCtx = preview.getContext('2d');
  const roiBox = document.getElementById('roi-box');
  const resultBox = document.getElementById('result');
  const toggleBtn = document.getElementById('togglePreview');
  const restartBtn = document.getElementById('restartBtn');

  const fullCanvas = document.getElementById('fullCanvas');
  const fullCtx = fullCanvas.getContext('2d', { willReadFrequently: true });
  const roiCanvas = document.getElementById('roiCanvas');
  const roiCtx = roiCanvas.getContext('2d', { willReadFrequently: true });

  // ROI Ø§ÙØªØ±Ø§Ø¶ÙŠ (Ù†Ø³Ø¨Ø© Ù…Ø¦ÙˆÙŠØ© Ø³ØªÙØ­ÙˆÙ‘ÙÙ„ Ø¥Ù„Ù‰ Ø¨ÙƒØ³Ù„ Ø¨Ø¹Ø¯ Ù…Ø¹Ø±ÙØ© Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ)
  const ROI_RATIO = { x: 200/640, y: 320/480, w: 250/640, h: 60/480 };

  let roiPx = { x:0,y:0,w:0,h:0 };
  let showPreview = false;
  let scanning = true;
  let ocrRunning = false;
  let workerReady = false;
  let videoReady = false;
  let lastAttempt = 0;
  const minInterval = 500;
  const requiredStable = 2;
  let lastText = null;
  let stableCount = 0;
  let worker = null;

  // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
      video.srcObject = stream;
    } catch (err) {
      resultBox.innerText = 'Camera error: ' + err.message;
    }
  }

  // ØªØ­ÙˆÙŠÙ„ Ù†Ø³Ø¨ ROI Ø¥Ù„Ù‰ Ø¨ÙƒØ³Ù„ Ø¹Ø±Ø¶ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶
  function computeROIPixels() {
    const displayW = video.clientWidth;
    const displayH = video.clientHeight;
    // Ø­Ø³Ø§Ø¨ Ù…Ø±ÙƒØ²ÙŠØ© Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙƒÙ…Ø§ ÙÙŠ CSS (left:50% translateX(-50%))
    const roiW = Math.round(displayW * ROI_RATIO.w);
    const roiH = Math.round(displayH * ROI_RATIO.h);
    const roiX = Math.round((displayW * ROI_RATIO.x));
    const roiY = Math.round((displayH * ROI_RATIO.y));
    // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ù†Ú¤Ø§Ø³ Ø§Ù„Ø°ÙŠ Ù†Ø³ØªØ®Ø¯Ù…Ù‡ (fullCanvas ÙŠØ³ØªØ®Ø¯Ù… Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø¨Ø§Ø·Ù†ÙŠØ© 640x480)
    // Ø³Ù†Ø­ÙˆÙ‘Ù„ Ù…Ù† Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¶ Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ© (fullCanvas.width/fullCanvas.clientWidth)
    const scaleX = fullCanvas.width / displayW;
    const scaleY = fullCanvas.height / displayH;
    roiPx = {
      x: Math.max(0, Math.min(fullCanvas.width-1, Math.round(roiX * scaleX))),
      y: Math.max(0, Math.min(fullCanvas.height-1, Math.round(roiY * scaleY))),
      w: Math.max(1, Math.min(fullCanvas.width, Math.round(roiW * scaleX))),
      h: Math.max(1, Math.min(fullCanvas.height, Math.round(roiH * scaleY)))
    };
    // Ù…Ø²Ø§Ù…Ù†Ø© Ø¹Ù†ØµØ± Ø§Ù„ preview Ù…Ø¹ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø¸Ø§Ù‡Ø±
    preview.style.width = (roiW) + 'px';
    preview.style.height = (roiH) + 'px';
    preview.style.left = '50%';
    preview.style.transform = 'translateX(-50%)';
    preview.style.top = roiBox.style.top;
    preview.width = roiW;
    preview.height = roiH;
  }

  // ØªÙ‡ÙŠØ¦Ø© worker ÙˆØ¥Ø¹Ø¯Ø§Ø¯Ø§ØªÙ‡
  (async function initWorker(){
    worker = Tesseract.createWorker({ logger: m => {/* optionally console.log(m) */} });
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    await worker.setParameters({
      tessedit_char_whitelist: 'ECP0123456789EG',
      tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
      tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY
    });
    workerReady = true;
    // Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„ÙˆØ¨ Ø¥Ø°Ø§ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¬Ø§Ù‡Ø²
    if (videoReady) startLoop();
  })();

  // Ø§Ø¬Ø¹Ù„ Ø§Ù„Ù€ toggle ÙŠØ¹Ù…Ù„ ÙˆÙŠØ¸Ù‡Ø± preview Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø±Ø¨Ø¹
  toggleBtn.addEventListener('click', () => {
    showPreview = !showPreview;
    preview.style.display = showPreview ? 'block' : 'none';
    toggleBtn.innerText = showPreview ? 'Ø§Ø®ÙØ§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©' : 'Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©';
  });

  restartBtn.addEventListener('click', () => {
    scanning = true;
    lastText = null;
    stableCount = 0;
    resultBox.innerText = 'Waiting...';
    if (workerReady && videoReady) startLoop();
  });

  // Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ¨Ø¯Ø£ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: Ø§Ø¶Ø¨Ø· Ø£Ø­Ø¬Ø§Ù… Ø§Ù„ÙƒØ§Ù†Ú¤Ø§Ø³Ø§Øª Ùˆ Ø­Ø³Ø§Ø¨ ROI Ø§Ù„Ø¨ÙƒØ³Ù„ÙŠ
  video.addEventListener('loadedmetadata', () => {
    // Ø§Ø¶Ø¨Ø· fullCanvas Ù„ÙŠØ·Ø§Ø¨Ù‚ Ø¯Ù‚Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© (Ø£Ùˆ Ø§Ø­ØªÙØ¸ Ø¨Ù€ 640x480)
    fullCanvas.width = video.videoWidth || 640;
    fullCanvas.height = video.videoHeight || 480;
    video.style.width = Math.min(640, window.innerWidth - 40) + 'px';
    video.style.height = (video.clientWidth * (fullCanvas.height / fullCanvas.width)) + 'px';
    computeROIPixels();
  });

  video.addEventListener('playing', () => {
    videoReady = true;
    computeROIPixels();
    if (workerReady) startLoop();
  });

  // ØªØ¬Ù‡ÙŠØ² ROI: crop Ù…Ù† fullCanvas Ø¥Ù„Ù‰ roiCanvas Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ø³ÙŠØ·Ø© Ø«Ù… Ø¥Ø±Ø¬Ø§Ø¹ blob
  function prepareROIBlob() {
    // Ø§Ø±Ø³Ù… Ø§Ù„ÙØ±ÙŠÙ… Ø§Ù„Ø­Ø§Ù„ÙŠ Ù…Ù† Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ fullCanvas
    fullCtx.drawImage(video, 0, 0, fullCanvas.width, fullCanvas.height);

    // Ø£Ù…Ø§Ù†: ØªØ£ÙƒØ¯ Ø£Ù† ROI Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ø¯ÙˆØ¯
    const sx = Math.max(0, Math.min(fullCanvas.width - 1, roiPx.x));
    const sy = Math.max(0, Math.min(fullCanvas.height - 1, roiPx.y));
    const sw = Math.max(1, Math.min(roiPx.w, fullCanvas.width - sx));
    const sh = Math.max(1, Math.min(roiPx.h, fullCanvas.height - sy));

    // Ø§Ø±Ø³Ù… Ø¥Ù„Ù‰ roiCanvas (Ø­Ø¬Ù… roiCanvas Ø«Ø§Ø¨Øª Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙƒØ³Ù„Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø©)
    const targetW = roiCanvas.width; // 360
    const targetH = roiCanvas.height; // 80
    roiCtx.clearRect(0,0,targetW,targetH);
    roiCtx.drawImage(fullCanvas, sx, sy, sw, sh, 0, 0, targetW, targetH);

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ø³ÙŠØ·Ø©: grayscale -> contrast -> threshold
    const img = roiCtx.getImageData(0,0,targetW,targetH);
    const data = img.data;
    const contrast = 1.5;
    const intercept = 128 * (1 - contrast);
    for (let i = 0; i < data.length; i += 4) {
      const g = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
      let v = g * contrast + intercept;
      data[i] = data[i+1] = data[i+2] = v;
    }
    const thresh = 150;
    for (let i = 0; i < data.length; i += 4) {
      const v = data[i] > thresh ? 255 : 0;
      data[i] = data[i+1] = data[i+2] = v;
    }
    roiCtx.putImageData(img, 0, 0);

    // Ø§Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹Ù„Ù‰ preview (Ø¨Ø´Ø±Ø· Ø£Ù† preview Ø¸Ø§Ù‡Ø±)
    if (showPreview) {
      // Ù†Ø±Ø³Ù… Ù†Ø³Ø®Ø© Ø¨Ø£Ø¨Ø¹Ø§Ø¯ preview.width/height Ù…Ø¨Ø§Ø´Ø±Ø©
      previewCtx.clearRect(0,0,preview.width, preview.height);
      previewCtx.drawImage(roiCanvas, 0, 0, preview.width, preview.height);
    }

    return new Promise(resolve => {
      roiCanvas.toBlob(b => {
        if (!b || b.size < 200) resolve(null); else resolve(b);
      }, 'image/png');
    });
  }

  // Ø¯Ø§Ù„Ø© OCR Ù…Ø¹ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± ÙˆØ§Ù„Ù€ regex ÙƒÙ…Ø§ Ù‡Ùˆ
  async function doOCR() {
    if (!scanning || ocrRunning || !workerReady) return;
    const now = Date.now();
    if (now - lastAttempt < minInterval) return;
    lastAttempt = now;
    ocrRunning = true;
    try {
      const blob = await prepareROIBlob();
      if (!blob) {
        resultBox.innerText = 'Preview empty - Ø§Ø¶Ø¨Ø· Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø£Ø­Ù…Ø±';
        ocrRunning = false;
        return;
      }
      const { data: { text } } = await worker.recognize(blob);
      const cleaned = (text || '').replace(/\s+/g, '');
      const match = cleaned.match(TARGET_REGEX); // Ø§Ø³ØªØ®Ø¯Ù…Ù†Ø§ Ø§Ù„Ø±ÙŠØ¬ÙŠÙƒØ³ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ ÙƒÙ…Ø§ Ù‡Ùˆ
      if (match) {
        const candidate = match[0];
        if (candidate === lastText) stableCount++; else { lastText = candidate; stableCount = 1; }
        if (stableCount >= requiredStable) {
          resultBox.innerText = 'âœ… Detected: ' + candidate;
          scanning = false;
        } else {
          resultBox.innerText = 'Confirming: ' + candidate + ' (' + stableCount + '/' + requiredStable + ')';
        }
      } else {
        lastText = null;
        stableCount = 0;
        resultBox.innerText = 'Waiting...';
      }
    } catch (err) {
      console.error(err);
      resultBox.innerText = 'OCR error';
    } finally {
      ocrRunning = false;
    }
  }

  // Ø­Ù„Ù‚Ø© ØªØ­ÙƒÙ… Ø¨Ø³ÙŠØ·Ø©
  let loopId = null;
  function startLoop() {
    if (loopId) return;
    scanning = true;
    resultBox.innerText = 'Waiting...';
    function step() {
      if (!scanning) { cancelAnimationFrame(loopId); loopId = null; return; }
      doOCR();
      loopId = requestAnimationFrame(step);
    }
    loopId = requestAnimationFrame(step);
  }

  // ØªÙ†Ø¸ÙŠÙ worker Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
  window.addEventListener('beforeunload', async () => {
    if (worker) await worker.terminate();
  });

  // Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙÙˆØ± ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
  startCamera();
</script>
</body>
</html>
