<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>OCR Tawkeel — Final Improved</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; text-align:center; padding:12px; }
    .viewer { position:relative; display:inline-block; }
    video { border:2px solid #444; border-radius:8px; background:#000; display:block; max-width:90vw; height:auto; }
    #roi-box { position:absolute; border:2px dashed red; box-sizing:border-box; pointer-events:none; }
    #preview-canvas { position:absolute; pointer-events:none; image-rendering:pixelated; border-radius:4px; display:none; }
    #controls { margin-top:12px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    #info { margin-top:10px; text-align:left; max-width:920px; margin-left:auto; margin-right:auto; }
    .row { display:flex; gap:8px; align-items:center; margin-top:6px; flex-wrap:wrap; }
    label { font-size:13px; min-width:70px; }
    input[type="range"] { width:180px; }
    pre { background:#f3f3f3; padding:8px; border-radius:6px; overflow:auto; max-height:200px; }
    button { padding:8px 12px; }
    #result { font-weight:bold; color:green; min-height:20px; }
    #log { font-size:12px; color:#666; min-height:18px; margin-top:6px; }
    @media (max-width:700px) {
      video { width:360px; height:270px; }
    }
  </style>
</head>
<body>
  <h3>OCR Tawkeel — Final Improved</h3>

  <div id="viewerRoot" class="viewer">
    <video id="video" autoplay playsinline muted></video>
    <div id="roi-box" aria-hidden="true"></div>
    <canvas id="preview-canvas"></canvas>
  </div>

  <div id="controls">
    <button id="togglePreview">عرض المعالجة</button>
    <button id="snapBtn">اختبار Snap</button>
    <button id="restartBtn">إعادة محاولة</button>
  </div>

  <div id="info">
    <div class="row">
      <div><strong>Result:</strong> <span id="result">Waiting...</span></div>
      <div id="log"></div>
    </div>

    <div class="row">
      <label>Raw OCR</label>
      <pre id="raw" style="flex:1">—</pre>
    </div>

    <div class="row">
      <label>Words (text : conf)</label>
      <pre id="words" style="flex:1">—</pre>
    </div>

    <div style="margin-top:10px;"><strong>ROI Tuner (حرك المربعات حتى يظهر السطر داخل المربع الأحمر)</strong></div>
    <div class="row">
      <label>X</label><input id="rX" type="range" min="0" max="100" value="50">
      <label>Y</label><input id="rY" type="range" min="0" max="100" value="72">
      <label>W</label><input id="rW" type="range" min="50" max="480" value="260">
      <label>H</label><input id="rH" type="range" min="20" max="240" value="60">
    </div>
  </div>

  <!-- كانڤاسات معالجة مخفية -->
  <canvas id="fullCanvas" style="display:none"></canvas>
  <canvas id="roiCanvas" width="360" height="80" style="display:none"></canvas>

<script>
/* لا تغيّر الـ regex */
const TARGET_REGEX = /ECP\d{8}EG/;

const video = document.getElementById('video');
const viewerRoot = document.getElementById('viewerRoot');
const roiBox = document.getElementById('roi-box');
const previewCanvas = document.getElementById('preview-canvas');
const previewCtx = previewCanvas.getContext('2d');
const resultBox = document.getElementById('result');
const rawBox = document.getElementById('raw');
const wordsBox = document.getElementById('words');
const logBox = document.getElementById('log');
const toggleBtn = document.getElementById('togglePreview');
const snapBtn = document.getElementById('snapBtn');
const restartBtn = document.getElementById('restartBtn');

const rX = document.getElementById('rX');
const rY = document.getElementById('rY');
const rW = document.getElementById('rW');
const rH = document.getElementById('rH');

const fullCanvas = document.getElementById('fullCanvas');
const fullCtx = fullCanvas.getContext('2d', { willReadFrequently: true });
const roiCanvas = document.getElementById('roiCanvas');
const roiCtx = roiCanvas.getContext('2d', { willReadFrequently: true });

// حالات
let showPreview = false;
let workerReady = false;
let videoReady = false;
let worker = null;
let scanning = true;
let ocrRunning = false;
let lastAttempt = 0;
const minInterval = 450;
const requiredStable = 2;
let lastText = null;
let stableCount = 0;

// ROI افتراضي
let ROI = { cxPerc: 50, cyPerc: 72, wPx: 260, hPx: 60 };

function log(msg){ logBox.innerText = msg; console.log(msg); }

// بدأ الكاميرا
async function startCamera(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
    video.srcObject = stream;
    log('Camera started');
  } catch (e) {
    resultBox.innerText = 'Camera error';
    log('Camera error: ' + e);
  }
}

// init worker
(async function initWorker(){
  worker = Tesseract.createWorker({ logger: m => { /* optional */ } });
  await worker.load();
  await worker.loadLanguage('eng');
  await worker.initialize('eng');
  await worker.setParameters({
    tessedit_char_whitelist: 'ECP0123456789EG',
    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
    tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY
  });
  workerReady = true;
  log('Worker ready');
  if (videoReady) startLoop();
})();

// تحديث بيانات ROI من منزلقات
function updateROIdataFromControls(){
  ROI.cxPerc = Number(rX.value);
  ROI.cyPerc = Number(rY.value);
  ROI.wPx = Number(rW.value);
  ROI.hPx = Number(rH.value);
  positionROIBox();
}

// وضع المربع الأحمر و الـ preview بمكان واحد
function positionROIBox(){
  const vRect = video.getBoundingClientRect();
  const rootRect = viewerRoot.getBoundingClientRect();
  const boxW = ROI.wPx;
  const boxH = ROI.hPx;
  const leftInViewer = Math.round((vRect.width * ROI.cxPerc/100) - boxW/2);
  const topInViewer = Math.round((vRect.height * ROI.cyPerc/100) - boxH/2);
  roiBox.style.width = boxW + 'px';
  roiBox.style.height = boxH + 'px';
  roiBox.style.left = (leftInViewer + (vRect.left - rootRect.left)) + 'px';
  roiBox.style.top = (topInViewer + (vRect.top - rootRect.top)) + 'px';
  // preview canvas same place/size
  previewCanvas.style.left = roiBox.style.left;
  previewCanvas.style.top = roiBox.style.top;
  previewCanvas.style.width = boxW + 'px';
  previewCanvas.style.height = boxH + 'px';
  previewCanvas.width = boxW;
  previewCanvas.height = boxH;
}

// حساب إحداثيات القطع على fullCanvas بدقة الفيديو الحقيقية
function computeROIforCapture(){
  const vRect = video.getBoundingClientRect();
  const vw = vRect.width, vh = vRect.height;
  const boxW = ROI.wPx, boxH = ROI.hPx;
  const leftInViewer = (vw * ROI.cxPerc/100) - boxW/2;
  const topInViewer = (vh * ROI.cyPerc/100) - boxH/2;
  // تحويل إلى إحداثيات fullCanvas (دقة الفيديو الحقيقية)
  const scaleX = fullCanvas.width / vw;
  const scaleY = fullCanvas.height / vh;
  const sx = Math.round(leftInViewer * scaleX);
  const sy = Math.round(topInViewer * scaleY);
  const sw = Math.round(boxW * scaleX);
  const sh = Math.round(boxH * scaleY);
  return { sx, sy, sw, sh, dstW: previewCanvas.width, dstH: previewCanvas.height };
}

// prepareROIBlob محسن: upscale ×2, sharpen, median blur, threshold, optional invert
async function prepareROIBlob(){
  // رسم فريم الفيديو على fullCanvas
  fullCtx.drawImage(video, 0, 0, fullCanvas.width, fullCanvas.height);
  const { sx, sy, sw, sh } = computeROIforCapture();

  // upscale factor (2x) لتحسين دقة Tesseract
  const factor = 2;
  const targetW = Math.max(200, Math.round(previewCanvas.width * factor));
  const targetH = Math.max(40, Math.round(previewCanvas.height * factor));
  roiCanvas.width = targetW;
  roiCanvas.height = targetH;
  roiCtx.clearRect(0,0,targetW,targetH);

  // حماية الحدود
  const safeSx = Math.max(0, Math.min(fullCanvas.width-1, sx));
  const safeSy = Math.max(0, Math.min(fullCanvas.height-1, sy));
  const safeSw = Math.max(1, Math.min(fullCanvas.width - safeSx, sw));
  const safeSh = Math.max(1, Math.min(fullCanvas.height - safeSy, sh));

  // crop -> resize (to roiCanvas)
  roiCtx.drawImage(fullCanvas, safeSx, safeSy, safeSw, safeSh, 0, 0, targetW, targetH);

  // get ImageData
  const img = roiCtx.getImageData(0,0,targetW,targetH);
  const data = img.data;
  const w = targetW, h = targetH;

  // 1) grayscale + contrast
  const contrastFactor = 1.6; // جرب 1.4-1.8 لتعديل دقة
  const intercept = 128 * (1 - contrastFactor);
  for (let i = 0; i < data.length; i += 4) {
    const g = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
    let v = g * contrastFactor + intercept;
    data[i] = data[i+1] = data[i+2] = v;
  }

  // 2) sharpen kernel (3x3): kernel = [0,-1,0; -1,5,-1; 0,-1,0]
  const copy = new Uint8ClampedArray(data);
  for (let y = 1; y < h-1; y++){
    for (let x = 1; x < w-1; x++){
      const idx = (y*w + x)*4;
      const center = copy[idx];
      const up = copy[((y-1)*w + x)*4];
      const down = copy[((y+1)*w + x)*4];
      const left = copy[(y*w + (x-1))*4];
      const right = copy[(y*w + (x+1))*4];
      let v = 5*center - up - down - left - right;
      v = Math.max(0, Math.min(255, v));
      data[idx] = data[idx+1] = data[idx+2] = v;
    }
  }

  // 3) median blur 3x3
  const tmp = new Uint8ClampedArray(data);
  for (let y = 1; y < h-1; y++){
    for (let x = 1; x < w-1; x++){
      const vals = [];
      for (let yy=-1; yy<=1; yy++){
        for (let xx=-1; xx<=1; xx++){
          const id = ((y+yy)*w + (x+xx))*4;
          vals.push(tmp[id]);
        }
      }
      vals.sort((a,b)=>a-b);
      const med = vals[4];
      const idc = (y*w + x)*4;
      data[idc] = data[idc+1] = data[idc+2] = med;
    }
  }

  // 4) threshold ثابت
  const thresh = 140;
  let whiteCount = 0;
  for (let i = 0; i < data.length; i += 4) {
    const v = data[i] > thresh ? 255 : 0;
    data[i] = data[i+1] = data[i+2] = v;
    if (v === 255) whiteCount++;
  }

  // 5) optional invert if background too white/black
  const whiteRatio = whiteCount / (data.length / 4);
  // إذا النسبة صغيرة (الخلفية غالباً داكنة والكتابة فاتحة) نحتفظ، أما إذا النص داكن على خلفية فاتحة فنعكس
  if (whiteRatio > 0.85) {
    // غالباً النص داكن على خلفية فاتحة => نعكس لتصبح الأرقام فاتحة على خلفية داكنة
    for (let i=0;i<data.length;i+=4){
      const v = 255 - data[i];
      data[i]=data[i+1]=data[i+2]=v;
    }
  }

  roiCtx.putImageData(img, 0, 0);

  // عرض preview (مقاس العرض الظاهر)
  if (showPreview) {
    previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    previewCtx.drawImage(roiCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
  }

  // إرجاع blob جاهز للـ OCR
  return new Promise(resolve => {
    roiCanvas.toBlob(b => {
      if (!b || b.size < 200) resolve(null); else resolve(b);
    }, 'image/png');
  });
}

// OCR logic with debug output
async function doOCR(){
  if (!workerReady || !videoReady) return;
  if (ocrRunning) return;
  const now = Date.now();
  if (now - lastAttempt < minInterval) return;
  lastAttempt = now;
  ocrRunning = true;
  try {
    const blob = await prepareROIBlob();
    if (!blob){ resultBox.innerText = 'Preview empty - اضبط ROI أو الإضاءة'; ocrRunning=false; return; }
    const { data } = await worker.recognize(blob);
    const text = (data && data.text) ? data.text : '';
    rawBox.textContent = text || '—';
    // عرض الكلمات مع confidence لتشخيص
    if (data && data.words && data.words.length){
      const lines = data.words.map(w => `${w.text} : ${Math.round(w.confidence)}`);
      wordsBox.textContent = lines.join('\n');
    } else {
      wordsBox.textContent = '—';
    }
    const cleaned = text.replace(/\s+/g,'');
    const match = cleaned.match(TARGET_REGEX); // استخدم الريجيكس كما هو
    if (match){
      const candidate = match[0];
      if (candidate === lastText) stableCount++; else { lastText = candidate; stableCount = 1; }
      if (stableCount >= requiredStable){ resultBox.innerText = '✅ Detected: ' + candidate; scanning=false; }
      else resultBox.innerText = 'Confirming: ' + candidate + ' ('+stableCount+'/'+requiredStable+')';
    } else {
      lastText = null; stableCount = 0; resultBox.innerText = 'Waiting...';
    }
  } catch (e){
    console.error(e);
    resultBox.innerText = 'OCR error';
    log('OCR error: ' + (e && e.message ? e.message : e));
  } finally { ocrRunning=false; }
}

// Loop
let raf = null;
function startLoop(){
  if (raf) return;
  scanning = true;
  resultBox.innerText = 'Waiting...';
  function step(){
    if (!scanning){ cancelAnimationFrame(raf); raf=null; return; }
    doOCR();
    raf = requestAnimationFrame(step);
  }
  raf = requestAnimationFrame(step);
}

// Snap button: open processed ROI in new tab for inspection
snapBtn.addEventListener('click', async () => {
  const blob = await prepareROIBlob();
  if (!blob) { alert('Preview empty or too small'); return; }
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank');
});

// toggle preview
toggleBtn.addEventListener('click', () => {
  showPreview = !showPreview;
  previewCanvas.style.display = showPreview ? 'block' : 'none';
  toggleBtn.innerText = showPreview ? 'اخفاء المعالجة' : 'عرض المعالجة';
});

// restart
restartBtn.addEventListener('click', () => {
  scanning=true; lastText=null; stableCount=0; resultBox.innerText='Waiting...';
  if (workerReady && videoReady) startLoop();
});

// sliders
[rX,rY,rW,rH].forEach(control => control.addEventListener('input', updateROIdataFromControls));
function updateROIdataFromControls(){
  ROI.cxPerc = Number(rX.value);
  ROI.cyPerc = Number(rY.value);
  ROI.wPx = Number(rW.value);
  ROI.hPx = Number(rH.value);
  positionROIBox();
}

// when video metadata ready
video.addEventListener('loadedmetadata', () => {
  fullCanvas.width = video.videoWidth || 1280;
  fullCanvas.height = video.videoHeight || 720;
  const maxW = Math.min(900, window.innerWidth - 40);
  video.style.width = maxW + 'px';
  video.style.height = (maxW * (fullCanvas.height / fullCanvas.width)) + 'px';
  // set initial ROI from controls
  rX.value = ROI.cxPerc; rY.value = ROI.cyPerc; rW.value = ROI.wPx; rH.value = ROI.hPx;
  updateROIdataFromControls();
  videoReady = true;
  log('Video ready');
  if (workerReady) startLoop();
});

// init camera
startCamera();

// cleanup
window.addEventListener('beforeunload', async () => { if (worker) await worker.terminate(); });

</script>
</body>
</html>
