<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>OCR Tawkeel â€” Reliable Preview</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; text-align:center; padding:12px; }
    .viewer { position:relative; display:inline-block; }
    video { border:2px solid #444; border-radius:8px; background:#000; display:block; max-width:90vw; height:auto; }
    #roi-box { position:absolute; width:260px; height:60px; border:2px dashed red; left:50%; transform:translateX(-50%); top:72%; box-sizing:border-box; pointer-events:none; }
    #preview-canvas { position:absolute; left:0; top:0; pointer-events:none; image-rendering:pixelated; display:none; border-radius:4px; box-shadow: 0 0 6px rgba(0,0,0,0.2); }
    #controls { margin-top:12px; }
    #result { font-weight:bold; color:green; min-height:26px; margin-top:10px; }
    #log { font-size:12px; color:#666; margin-top:8px; min-height:18px; }
    button { padding:8px 12px; margin:0 6px; }
  </style>
</head>
<body>
  <h3>OCR Tawkeel â€” Reliable Preview</h3>

  <div id="viewerRoot" class="viewer">
    <video id="video" autoplay playsinline muted></video>
    <div id="roi-box" aria-hidden="true"></div>
    <canvas id="preview-canvas"></canvas>
  </div>

  <div id="controls">
    <button id="togglePreview">Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©</button>
    <button id="snapBtn">Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªÙ‚Ø§Ø· ROI</button>
    <button id="restartBtn">ðŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©</button>
  </div>

  <div id="result">Waiting...</div>
  <div id="log"></div>

  <!-- ÙƒØ§Ù†Ú¤Ø§Ø³Ø§Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø®ÙÙŠØ© -->
  <canvas id="fullCanvas" style="display:none"></canvas>
  <canvas id="roiCanvas" width="360" height="80" style="display:none"></canvas>

<script>
/* Ù„Ø§ ØªØºÙŠÙŠØ± Ù„Ù„Ø±ÙŠØ¬ÙŠÙƒØ³ */
const TARGET_REGEX = /ECP\d{8}EG/;

const video = document.getElementById('video');
const viewerRoot = document.getElementById('viewerRoot');
const roiBox = document.getElementById('roi-box');
const previewCanvas = document.getElementById('preview-canvas');
const previewCtx = previewCanvas.getContext('2d');
const resultBox = document.getElementById('result');
const logBox = document.getElementById('log');
const toggleBtn = document.getElementById('togglePreview');
const snapBtn = document.getElementById('snapBtn');
const restartBtn = document.getElementById('restartBtn');

const fullCanvas = document.getElementById('fullCanvas');
const fullCtx = fullCanvas.getContext('2d', { willReadFrequently: true });
const roiCanvas = document.getElementById('roiCanvas');
const roiCtx = roiCanvas.getContext('2d', { willReadFrequently: true });

// Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ´ØºÙŠÙ„
let showPreview = false;
let videoReady = false;
let workerReady = false;
let worker = null;
let scanning = true;
let ocrRunning = false;
let lastAttempt = 0;
const minInterval = 500;
const requiredStable = 2;
let lastText = null;
let stableCount = 0;

// ROI Ø¨ØµÙŠØºØ© Ù†Ø³Ø¨ÙŠØ© Ù…Ø¦ÙˆÙŠØ© ÙˆØ§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¨ÙƒØ³Ù„ ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø­Ø¬Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø¸Ø§Ù‡Ø±
const ROI_RATIO = { cx: 0.5, cy: 0.72, w: 260, h: 60 }; // cx,cy ÙƒÙ†Ù‚Ø§Ø· Ù…Ø±ÙƒØ²ÙŠØ© Ù†Ø³Ø¨ÙŠØ© Ù„Ù„Ø¹Ø±Ø¶ ÙˆØ§Ù„Ø§Ø±ØªÙØ§Ø¹
function computeROIBounds() {
  const vRect = video.getBoundingClientRect();
  const vw = vRect.width;
  const vh = vRect.height;
  // Ù†Ø­Ø³Ø¨ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø¸Ø§Ù‡Ø± Ø¯Ø§Ø®Ù„ Ø¹Ù†ØµØ± Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
  const boxW = ROI_RATIO.w;
  const boxH = ROI_RATIO.h;
  const left = (vRect.left + window.scrollX) + (vw/2 - boxW/2);
  const top = (vRect.top + window.scrollY) + (vh * ROI_RATIO.cy - boxH/2);
  // Ø¶Ø¨Ø· preview canvas Ù„ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø¸Ø§Ù‡Ø±
  previewCanvas.style.left = (left - (viewerRoot.getBoundingClientRect().left + window.scrollX)) + 'px';
  previewCanvas.style.top = (top - (viewerRoot.getBoundingClientRect().top + window.scrollY)) + 'px';
  previewCanvas.style.width = boxW + 'px';
  previewCanvas.style.height = boxH + 'px';
  previewCanvas.width = Math.round(boxW);
  previewCanvas.height = Math.round(boxH);
  // Ø­Ø³Ø§Ø¨ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ROI Ø¹Ù„Ù‰ fullCanvas Ø¨Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù„Ù„ÙÙŠØ¯ÙŠÙˆ
  const scaleX = fullCanvas.width / vw;
  const scaleY = fullCanvas.height / vh;
  const sx = Math.round((vw/2 - boxW/2) * scaleX);
  const sy = Math.round((vh * ROI_RATIO.cy - boxH/2) * scaleY);
  const sw = Math.round(boxW * scaleX);
  const sh = Math.round(boxH * scaleY);
  return { sx, sy, sw, sh, boxW, boxH };
}

// Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
async function startCamera(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
    video.srcObject = stream;
    log('Camera started');
  } catch (e) {
    resultBox.innerText = 'Camera error: ' + (e && e.message ? e.message : e);
    log('Camera error: ' + e);
  }
}

// ØªÙ‡ÙŠØ¦Ø© Ø¹Ø§Ù…Ù„ Tesseract
(async function initWorker(){
  worker = Tesseract.createWorker({ logger: m => {/* optional logging */} });
  await worker.load();
  await worker.loadLanguage('eng');
  await worker.initialize('eng');
  await worker.setParameters({
    tessedit_char_whitelist: 'ECP0123456789EG',
    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
    tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY
  });
  workerReady = true;
  log('Worker ready');
  if (videoReady) startLoop();
})();

// Ø¹Ù†Ø¯Ù…Ø§ ÙŠØªÙˆÙØ± Ø¯Ø§ØªØ§ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
video.addEventListener('loadedmetadata', () => {
  // Ø§Ø¶Ø¨Ø· fullCanvas Ø¨Ø¯Ù‚Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„ÙØ¹Ù„ÙŠØ©
  fullCanvas.width = video.videoWidth || 1280;
  fullCanvas.height = video.videoHeight || 720;
  // Ø¶Ø¨Ø· Ø¹Ø±Ø¶ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø¸Ø§Ù‡Ø±ÙŠ Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„Ø´Ø§Ø´Ø©
  const maxW = Math.min(900, window.innerWidth - 40);
  video.style.width = maxW + 'px';
  video.style.height = (maxW * (fullCanvas.height / fullCanvas.width)) + 'px';
  // Ù…Ø²Ø§Ù…Ù†Ø© Ù…ÙƒØ§Ù† Ø§Ù„Ù€ roi initial
  computeROIBounds();
});

video.addEventListener('playing', () => {
  videoReady = true;
  computeROIBounds();
  log('Video playing');
  if (workerReady) startLoop();
});

// Ø²Ø± Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
toggleBtn.addEventListener('click', () => {
  showPreview = !showPreview;
  previewCanvas.style.display = showPreview ? 'block' : 'none';
  toggleBtn.innerText = showPreview ? 'Ø§Ø®ÙØ§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©' : 'Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©';
  computeROIBounds();
});

// Ø²Ø± Ø§Ø®ØªØ¨Ø§Ø± Ù„Ø§Ù„ØªÙ‚Ø§Ø· Ù„Ù‚Ø·Ø© ROI ÙÙˆØ±ÙŠØ© ÙˆØ¹Ø±Ø¶Ù‡Ø§ ÙÙŠ Ù†Ø§ÙØ°Ø© Ø¬Ø¯ÙŠØ¯Ø©
snapBtn.addEventListener('click', async () => {
  const b = await prepareROIBlob();
  if (!b) { alert('ROI empty or too small'); return; }
  const url = URL.createObjectURL(b);
  window.open(url, '_blank');
});

// Ø²Ø± Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
restartBtn.addEventListener('click', () => {
  scanning = true; lastText = null; stableCount = 0; resultBox.innerText = 'Waiting...';
  if (workerReady && videoReady) startLoop();
});

// ØªØ­Ø¶ÙŠØ± ROI: Ù‚Øµ Ù…Ù† fullCanvasØŒ Ù…Ø¹Ø§Ù„Ø¬Ø©ØŒ Ù†Ø³Ø® Ø¥Ù„Ù‰ previewØŒ Ø§Ø±Ø¬Ø§Ø¹ blob
function prepareROIBlob(){
  // Ø§Ø±Ø³Ù… ÙØ±ÙŠÙ… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¹Ù„Ù‰ fullCanvas Ø¨Ù…Ù‚ÙŠØ§Ø³ Ø¯Ù‚ÙŠÙ‚
  fullCtx.drawImage(video, 0, 0, fullCanvas.width, fullCanvas.height);
  const { sx, sy, sw, sh, boxW, boxH } = computeROIBounds();
  // Ø­Ù…Ø§ÙŠØ© Ø­Ø¯ÙˆØ¯
  const safeSx = Math.max(0, Math.min(fullCanvas.width - 1, sx));
  const safeSy = Math.max(0, Math.min(fullCanvas.height - 1, sy));
  const safeSw = Math.max(1, Math.min(fullCanvas.width - safeSx, sw));
  const safeSh = Math.max(1, Math.min(fullCanvas.height - safeSy, sh));
  // Ø±Ø³Ù… Ø§Ù„Ø¬Ø²Ø¡ Ø¥Ù„Ù‰ roiCanvas Ø§Ù„Ù…ØµØºØ± (Ø«Ø§Ø¨Øª)
  const targetW = roiCanvas.width;
  const targetH = roiCanvas.height;
  roiCtx.clearRect(0,0,targetW,targetH);
  roiCtx.drawImage(fullCanvas, safeSx, safeSy, safeSw, safeSh, 0, 0, targetW, targetH);
  // Ù…Ø¹Ø§Ù„Ø¬Ø©: grayscale -> contrast -> threshold
  const img = roiCtx.getImageData(0,0,targetW,targetH);
  const data = img.data;
  const contrast = 1.5;
  const intercept = 128 * (1 - contrast);
  for (let i = 0; i < data.length; i += 4) {
    const g = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
    let v = g * contrast + intercept;
    data[i] = data[i+1] = data[i+2] = v;
  }
  const thresh = 150;
  for (let i = 0; i < data.length; i += 4) {
    const v = data[i] > thresh ? 255 : 0;
    data[i] = data[i+1] = data[i+2] = v;
  }
  roiCtx.putImageData(img, 0, 0);
  // Ø¹Ø±Ø¶ Ø§Ù„Ù€ preview Ø¹Ø¨Ø± Ù†Ø³Ø® Ù…Ù† roiCanvas Ø¥Ù„Ù‰ previewCanvas Ø¨Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ù…Ø±Ø¦ÙŠ
  if (showPreview) {
    previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    previewCtx.drawImage(roiCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
  }
  // Ø¥Ø±Ø¬Ø§Ø¹ blob Ù…Ø¹ ÙØ­Øµ Ø§Ù„Ø­Ø¬Ù…
  return new Promise(resolve => {
    roiCanvas.toBlob(b => {
      if (!b || b.size < 200) resolve(null); else resolve(b);
    }, 'image/png');
  });
}

// Ù…Ù†Ø·Ù‚ Ø§Ù„Ù€ OCR Ù…Ø¹ Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙˆØ§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±ÙŠØ¬ÙŠÙƒØ³ ÙƒÙ…Ø§ Ù‡Ùˆ
async function doOCR(){
  if (!scanning || ocrRunning || !workerReady) return;
  const now = Date.now();
  if (now - lastAttempt < minInterval) return;
  lastAttempt = now;
  ocrRunning = true;
  try {
    const blob = await prepareROIBlob();
    if (!blob) { resultBox.innerText = 'Preview empty - Ø§Ø¶Ø¨Ø· Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø£Ø­Ù…Ø± Ø£Ùˆ Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©'; ocrRunning = false; return; }
    const { data: { text } } = await worker.recognize(blob);
    const cleaned = (text||'').replace(/\s+/g,'');
    const match = cleaned.match(TARGET_REGEX); // Ù†ÙØ³ Ø§Ù„Ø±ÙŠØ¬ÙŠÙƒØ³ ÙƒÙ…Ø§ Ø·Ù„Ø¨Øª
    if (match) {
      const candidate = match[0];
      if (candidate === lastText) stableCount++; else { lastText = candidate; stableCount = 1; }
      if (stableCount >= requiredStable) { resultBox.innerText = 'âœ… Detected: ' + candidate; scanning = false; }
      else resultBox.innerText = 'Confirming: ' + candidate + ' ('+stableCount+'/'+requiredStable+')';
    } else {
      lastText = null; stableCount = 0; resultBox.innerText = 'Waiting...';
    }
  } catch (e) {
    console.error(e);
    resultBox.innerText = 'OCR error';
    log('OCR error: ' + (e && e.message ? e.message : e));
  } finally {
    ocrRunning = false;
  }
}

// Ø­Ù„Ù‚Ø© ØªØ¯ÙÙ‚ Ù‡Ø§Ø¯Ø¦Ø©
let raf = null;
function startLoop(){
  if (raf) return;
  scanning = true;
  resultBox.innerText = 'Waiting...';
  function step(){
    if (!scanning) { cancelAnimationFrame(raf); raf = null; return; }
    doOCR();
    raf = requestAnimationFrame(step);
  }
  raf = requestAnimationFrame(step);
}

// Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¹Ø±Ø¶ Ø±Ø³Ø§Ø¦Ù„
function log(msg){ logBox.innerText = msg; console.log(msg); }

// Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙÙˆØ± Ø§Ù„ØªØ­Ù…ÙŠÙ„
startCamera();

// ØªÙ†Ø¸ÙŠÙ worker Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
window.addEventListener('beforeunload', async () => { if (worker) await worker.terminate(); });

</script>
</body>
</html>
